<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>World Hopper Labs</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <style>
    body{max-width:1100px;margin:auto}
    code,.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .muted{opacity:.7}
    .error{color:#b00020}
    .ok{color:#0b8457}
    #worlds{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:.5rem}
    .small{font-size:.9em}
  </style>
</head>
<body>
  <header>
    <h1>World Hopper Labs</h1>
    <p class="mono muted">Measure OSRS latency & TCP pathing from your ISP + region.</p>
  </header>

  <main>
    <article>
      <form id="runForm">
        <div class="grid">
          <!-- ASN: dropdown -->
          <label>ISP (ASN)
            <select id="asn" required>
              <option disabled selected value="">Loading ISPs…</option>
            </select>
          </label>

          <!-- Capital: full names shown; value is the short code used by API -->
          <label>Closest capital
            <select id="capital" required>
              <option value="SYD">Sydney</option>
              <option value="MEL" selected>Melbourne</option>
              <option value="BNE">Brisbane</option>
              <option value="ADL">Adelaide</option>
              <option value="PER">Perth</option>
              <option value="CBR">Canberra</option>
              <option value="HBA">Hobart</option>
              <option value="DRW">Darwin</option>
              <option value="AKL">Auckland</option>
              <option value="WLG">Wellington</option>
              <option value="CHC">Christchurch</option>
            </select>
          </label>

          <!-- Port: dropdown -->
          <label>TCP Port
            <select id="port" required>
              <option value="43594" selected>43594</option>
              <option value="43595">43595</option>
            </select>
          </label>
        </div>

        <details open>
          <summary>Worlds (select up to 5)</summary>
          <div id="worlds" class="small"></div>
        </details>

        <button id="runBtn" type="submit">Run test</button>
        <span id="status" class="mono muted" style="margin-left:.6rem;">Ready.</span>
      </form>
    </article>

    <article>
      <h3>Results</h3>
      <table role="grid">
        <thead>
          <tr>
            <th>World</th><th>Probe</th><th>RTT med</th><th>p95</th>
            <th>Jitter</th><th>Loss %</th><th>Hops</th><th>Last-hop RTT</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
      <p class="small muted">Note: results usually arrive within ~3–15s; we poll with backoff up to ~75s.</p>
    </article>
  </main>

  <script>
  // ==== CONFIG ====
  const API_BASE = "https://api.whl.freshcuppa.wtf";
  const WORLDS_JSON = "/data/worlds-au-nz.json";
  const ASN_SEEDS_JSON = "/data/asn-seeds.json"; // optional file you can maintain
  const MAX_WORLDS = 5;

  // Fallback ASN seeds (used only if /data/asn-seeds.json is missing)
  // Format of /data/asn-seeds.json should be: [{ "asn": 1221, "label": "Telstra (AS1221, AU)" }, ...]
  const FALLBACK_ASN_SEEDS = [
    { asn: 1221,  label: "Telstra – AU (AS1221)" },
    { asn: 4764,  label: "Aussie Broadband – AU (AS4764)" },
    { asn: 4826,  label: "Vocus/Orcon – AU (AS4826)" },
    { asn: 7545,  label: "TPG – AU (AS7545)" },
    { asn: 7474,  label: "Optus – AU (AS7474)" },
    { asn: 38195, label: "Superloop – AU (AS38195)" },
    { asn: 4739,  label: "iiNet – AU (AS4739)" },
    { asn: 58470, label: "Launtel – AU (AS58470)" },
    { asn: 4771,  label: "Spark – NZ (AS4771)" },
    { asn: 9500,  label: "Vodafone/One – NZ (AS9500)" },
    { asn: 9790,  label: "Vocus – NZ (AS9790)" },
    { asn: 23655, label: "2degrees – NZ (AS23655)" },
  ];

  // ==== helpers ====
  const $ = (id) => document.getElementById(id);
  const setStatus = (msg, cls="muted") => { const el=$("status"); el.textContent=msg; el.className=`mono ${cls}`; };
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const safe = (v)=> (v==null || v==="") ? "—" : v;

  // Load ASN seeds from JSON, fallback if missing
  async function loadAsnSeeds() {
    let list = null;
    try {
      const r = await fetch(ASN_SEEDS_JSON, { cache: "no-cache" });
      if (r.ok) list = await r.json();
    } catch (_) {}
    if (!Array.isArray(list) || list.length === 0) list = FALLBACK_ASN_SEEDS;

    const sel = $("asn");
    sel.innerHTML = "";
    for (const item of list) {
      const opt = document.createElement("option");
      opt.value = String(item.asn);
      opt.textContent = item.label || `AS${item.asn}`;
      sel.appendChild(opt);
    }
    // Try to default to Telstra (1221) if present
    if ([...sel.options].some(o=>o.value==="1221")) sel.value = "1221";
  }

  async function loadWorlds(){
    try{
      const r = await fetch(WORLDS_JSON, {cache:"no-cache"});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      const list = await r.json();
      const wrap = $("worlds"); wrap.innerHTML = "";
      list.forEach((w,i) => {
        const id = `w_${i}`;
        const label = document.createElement("label");
        label.innerHTML = `
          <input type="checkbox" id="${id}" value="${encodeURIComponent(JSON.stringify(w))}">
          ${w.name} <span class="muted">(${w.host})</span>`;
        wrap.appendChild(label);
      });
      setStatus("Done.", "ok");
    }catch(e){
      setStatus(`Failed to load world list: ${e.message||e}`, "error");
    }
  }

  async function selectProbe(asn, capital){
    const r = await fetch(`${API_BASE}/probes?asn=${encodeURIComponent(asn)}&capital=${encodeURIComponent(capital)}`);
    const j = await r.json().catch(()=>({error:"bad_json"}));
    if(!r.ok || j.error) throw new Error(j.error || `probe_http_${r.status}`);
    return j.probe.id;
  }

  async function createMeasurement(asn, capital, worlds, port){
    const body = JSON.stringify({ asn, capital, worlds, tcp_port: port });
    const r = await fetch(`${API_BASE}/measure`, {
      method:"POST", headers:{ "content-type":"application/json" }, body
    });
    const j = await r.json().catch(()=>({error:"bad_json"}));
    if(!r.ok || j.error) throw new Error(j.error || `measure_http_${r.status}`);
    return j.run_id;
  }

  async function fetchResults(runId){
    const r = await fetch(`${API_BASE}/results?run=${encodeURIComponent(runId)}`);
    if(!r.ok) return null;
    const j = await r.json().catch(()=>null);
    if(!j || !Array.isArray(j.results)) return null;
    return j;
  }

  function renderResults(res){
    const tb = $("tbody"); tb.innerHTML = "";
    res.results.forEach(row=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${safe(row.world)}</td>
        <td>${safe(res.probe_id)}</td>
        <td>${safe(row.ping?.rtt_med)}</td>
        <td>${safe(row.ping?.rtt_p95)}</td>
        <td>${safe(row.ping?.jitter)}</td>
        <td>${safe(row.ping?.loss_pct)}</td>
        <td>${safe(row.traceroute?.hops)}</td>
        <td>${safe(row.traceroute?.final_hop_rtt)}</td>`;
      tb.appendChild(tr);
    });
  }

  $("runForm").addEventListener("submit", async (evt)=>{
    evt.preventDefault();
    const btn = $("runBtn"); btn.setAttribute("aria-busy", "true"); btn.disabled = true;
    $("tbody").innerHTML = "";

    try{
      const asn = Number($("asn").value);
      const capital = $("capital").value;         // short code value (e.g., "MEL")
      const port = Number($("port").value)||43594;

      const checks = [...document.querySelectorAll("#worlds input[type=checkbox]:checked")];
      if(checks.length === 0) throw new Error("select_at_least_one_world");
      if(checks.length > MAX_WORLDS) throw new Error(`max_${MAX_WORLDS}_worlds`);
      const worlds = checks.map(c => JSON.parse(decodeURIComponent(c.value)).host);

      setStatus("Selecting probe…");
      await selectProbe(asn, capital); // fail-fast; Worker can also auto-select

      setStatus("Creating measurements…");
      const runId = await createMeasurement(asn, capital, worlds, port);
      setStatus(`Run created. Waiting for results…`);

      // Poll up to ~75s; require BOTH ping & traceroute per world
      const schedule = [2000, 3000, 4000, 5000, 7000, 9000, 12000, 15000, 18000, 20000];
      let allDone = false;

      for (let i = 0; i < schedule.length; i++) {
        await sleep(schedule[i]);

        const res = await fetchResults(runId);
        if (res) {
          renderResults(res);

          const perWorldDone = res.results.map(row => {
            const pingReady = Number(row?.ping?.samples || 0) > 0;
            const trReady   = row?.traceroute?.hops != null;
            return pingReady && trReady;
          });

          const doneCount = perWorldDone.filter(Boolean).length;
          allDone = doneCount === res.results.length;

          if (allDone) {
            setStatus("Done.", "ok");
            break;
          } else {
            setStatus(`Waiting for traceroutes… ${doneCount}/${res.results.length} worlds ready (attempt ${i+1}/${schedule.length})`);
          }
        } else {
          setStatus(`Waiting for results… (attempt ${i+1}/${schedule.length})`);
        }
      }

      if (!allDone) setStatus("Timed out waiting for traceroutes.", "error");
    }catch(err){
      setStatus(String(err.message || err), "error");
    }finally{
      btn.removeAttribute("aria-busy"); btn.disabled = false;
    }
  });

  // init
  loadAsnSeeds();
  loadWorlds();
  </script>
</body>
</html>
