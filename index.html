<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>World Hopper Labs — AU/NZ</title>
<link rel="icon" href="favicon.ico" />
<style>
  :root{
    --bg:#0f1620; --panel:#121b26; --panel-2:#0d141d; --text:#e7eef6; --muted:#9fb3c8;
    --accent:#1f6feb; --accent-2:#2483ff; --ok:#2ecc71; --warn:#f1c40f; --bad:#e74c3c;
    --chip:#1b2735; --chip-border:#203044; --table:#0f1823;
  }
  html,body{ background:var(--bg); color:var(--text); font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin:0; }
  .wrap{ max-width:1150px; margin:28px auto; padding:0 16px; }
  h1{ font-size:28px; margin:0 0 6px; }
  p.sub{ color:var(--muted); margin:0 0 22px; }
  .grid{ display:grid; gap:18px; grid-template-columns: 1fr 1fr; }
  .card{ background:var(--panel); border:1px solid #1b2634; border-radius:12px; padding:16px; }
  .card h2{ margin:0 0 12px; font-size:18px; }
  label.lbl{ display:block; color:var(--muted); font-size:12px; margin:10px 0 6px; }
  select, input[type="text"]{ width:100%; background:var(--panel-2); color:var(--text);
    border:1px solid #223246; border-radius:8px; padding:10px 12px; }
  .row{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }
  .help{ color:var(--muted); font-size:12px; margin-top:8px; }
  .note{ font-size:12px; color:var(--muted); }
  .danger{ color:var(--bad); }
  .ok{ color:var(--ok); }
  .btn{ background:var(--accent); border:0; color:white; border-radius:10px; padding:10px 14px; cursor:pointer; }
  .btn[disabled]{ opacity:.6; cursor:not-allowed; }
  .btn.secondary{ background:#1a2636; }
  .chips{ display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
  .chip{ background:var(--chip); border:1px solid var(--chip-border); color:var(--muted);
    border-radius:999px; padding:3px 8px; font-size:12px; }
  .worlds{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
  .world{ background:var(--panel-2); border:1px solid #1c2a3c; border-radius:10px; padding:10px 12px; }
  .world header{ display:flex; justify-content:space-between; align-items:center; gap:12px; }
  .world small{ color:var(--muted); }
  .world .meta{ margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; }
  .world .select{ display:flex; align-items:center; gap:8px; margin-top:8px; }
  .world .select input{ width:18px; height:18px; }
  .divider{ height:1px; background:#1b2634; margin:18px 0; }
  table{ width:100%; border-collapse:collapse; background:var(--table); border:1px solid #1b2634; border-radius:12px; overflow:hidden; }
  thead th{ text-align:left; font-weight:600; font-size:13px; color:var(--muted); padding:10px 12px; background:#101a26; }
  tbody td{ padding:10px 12px; border-top:1px solid #1b2634; }
  .status{ font-size:12px; color:var(--muted); }
  .toolbar{ display:flex; gap:10px; align-items:center; }
  .right{ display:flex; justify-content:flex-end; }
  .flex{ display:flex; align-items:center; gap:10px; }
</style>
</head>
<body>
<div class="wrap">
  <h1>World Hopper Labs — AU/NZ</h1>
  <p class="sub">Quickly test RTT / loss and TCP traceroute from a RIPE Atlas probe near your ISP + city to OSRS worlds.</p>

  <div class="grid">
    <!-- Left: Network -->
    <div class="card">
      <h2>1) Choose network &amp; region</h2>
      <div class="row">
        <div>
          <label class="lbl">ISP (ASN)</label>
          <select id="asn"></select>
          <div id="asnErr" class="danger help" style="display:none"></div>
        </div>
        <div>
          <label class="lbl">Closest city</label>
          <select id="capital">
            <option value="SYD">Sydney</option>
            <option value="MEL" selected>Melbourne</option>
            <option value="BNE">Brisbane</option>
            <option value="ADL">Adelaide</option>
            <option value="PER">Perth</option>
            <option value="CBR">Canberra</option>
            <option value="HBA">Hobart</option>
            <option value="DRW">Darwin</option>
            <option value="AKL">Auckland</option>
            <option value="WLG">Wellington</option>
            <option value="CHC">Christchurch</option>
          </select>
        </div>
        <div>
          <label class="lbl">Game port</label>
          <select id="tcpPort">
            <option value="43594" selected>43594</option>
            <option value="43595">43595</option>
          </select>
        </div>
      </div>

      <div class="flex" style="margin-top:10px;">
        <label class="flex" title="Bypass cached probe selection for a fresh, nearest probe">
          <input type="checkbox" id="bypassCache" /> Bypass probe cache (force fresh selection)
        </label>
      </div>
      <div class="help">CORS is limited to this Pages domain; your browser will call <code>https://api.whl.freshcuppa.wtf</code>.</div>
    </div>

    <!-- Right: Worlds -->
    <div class="card">
      <h2>2) Pick worlds</h2>
      <div id="worlds" class="worlds"></div>
      <div class="toolbar" style="margin-top:10px;">
        <button id="toggleMore" class="btn secondary">Show all</button>
        <div class="right" style="flex:1"></div>
        <button id="startBtn" class="btn">Start measurement</button>
      </div>
      <div class="help">Select up to 5 worlds.</div>
    </div>
  </div>

  <div class="card" style="margin-top:18px;">
    <h2>3) Results</h2>
    <table>
      <thead>
        <tr>
          <th>World</th>
          <th>Port</th>
          <th>Members</th>
          <th>Activity</th>
          <th>Median RTT</th>
          <th>p95 RTT</th>
          <th>Jitter</th>
          <th>Loss %</th>
          <th>Hops</th>
          <th>Final hop RTT</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody id="resultsBody"></tbody>
    </table>
    <div class="note" style="margin-top:8px;">Note: results usually arrive within ~3–15s; we poll with backoff up to ~75s.</div>
  </div>
</div>

<script>
  // -------- Config --------
  const API_BASE = "https://api.whl.freshcuppa.wtf";
  const ASNS_URL = "asn-seeds.json";
  const WORLDS_URL = "worlds-au-nz.json";
  const MAX_WORLDS = 5;
  const INITIAL_VISIBLE_WORLDS = 6;

  // Data holders
  let allWorlds = [];
  let showingAll = false;

  // -------- ASN loader (handles AU/NZ object shape) --------
  async function loadASNs(){
    try{
      const r = await fetch(ASNS_URL, { cache:"no-cache" });
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      const raw = await r.json();

      const items = [];
      const addArr = (arr, cc) => Array.isArray(arr) && arr.forEach(s => items.push({ ...s, cc }));
      addArr(raw?.AU, "AU");
      addArr(raw?.NZ, "NZ");

      if(items.length === 0){
        // fallbacks if file shape changes
        if(Array.isArray(raw)) items.push(...raw);
        else if(raw && Array.isArray(raw.items)) items.push(...raw.items);
        else if(raw && typeof raw === "object"){
          for(const [k,v] of Object.entries(raw)){
            if(Array.isArray(v)) addArr(v, k.toUpperCase());
            else if(v && typeof v === "object") items.push(v);
          }
        }
      }

      const norm = [];
      for(const s of items){
        const asStr = (s.asn ?? s.ASN ?? s.id ?? s.number ?? s.as ?? "").toString();
        const asn = parseInt(asStr.replace(/^AS/i,""),10);
        if(!Number.isFinite(asn) || asn<=0) continue;
        const label = s.label ?? s.name ?? s.isp ?? s.org ?? `AS${asn}`;
        const cc = (s.cc ?? s.country ?? s.country_code ?? "").toString().toUpperCase();
        norm.push({ asn, label, cc });
      }

      // dedupe
      const dedup = new Map();
      norm.forEach(x => { if(!dedup.has(x.asn)) dedup.set(x.asn, x); });
      const list = Array.from(dedup.values());

      const groups = {
        AU: list.filter(x => x.cc === "AU").sort((a,b)=>a.label.localeCompare(b.label)),
        NZ: list.filter(x => x.cc === "NZ").sort((a,b)=>a.label.localeCompare(b.label)),
        OTHER: list.filter(x => x.cc !== "AU" && x.cc !== "NZ").sort((a,b)=>a.label.localeCompare(b.label)),
      };

      const sel = document.getElementById("asn");
      sel.innerHTML = "";
      const makeGroup = (label, arr) => {
        if(!arr.length) return;
        const og = document.createElement("optgroup");
        og.label = label;
        arr.forEach(x => {
          const opt = document.createElement("option");
          opt.value = String(x.asn);
          opt.textContent = `${x.label} (AS${x.asn})`;
          og.appendChild(opt);
        });
        sel.appendChild(og);
      };

      if(groups.AU.length || groups.NZ.length){
        makeGroup("Australia", groups.AU);
        makeGroup("New Zealand", groups.NZ);
        makeGroup("Other", groups.OTHER);
      } else {
        list.sort((a,b)=>a.label.localeCompare(b.label)).forEach(x=>{
          const opt = document.createElement("option");
          opt.value = String(x.asn);
          opt.textContent = `${x.label} (AS${x.asn})`;
          sel.appendChild(opt);
        });
      }
      if(!sel.options.length){
        const opt=document.createElement("option");
        opt.value="1221"; opt.textContent="Telstra — AU (AS1221)";
        sel.appendChild(opt);
      }
      document.getElementById("asnErr").style.display="none";
    }catch(err){
      console.error("ASN load failed:", err);
      const sel = document.getElementById("asn");
      sel.innerHTML = "";
      const opt=document.createElement("option");
      opt.value="1221"; opt.textContent="Telstra — AU (AS1221)";
      sel.appendChild(opt);
      const e = document.getElementById("asnErr");
      e.style.display="block";
      e.textContent="Failed to load ISP list; using fallback.";
    }
  }

  // -------- Worlds loader and renderer --------
  async function loadWorlds(){
    const r = await fetch(WORLDS_URL, { cache:"no-cache" });
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    allWorlds = await r.json();
    renderWorlds();
  }

  function renderWorlds(){
    const container = document.getElementById("worlds");
    container.innerHTML = "";
    const visible = showingAll ? allWorlds : allWorlds.slice(0, INITIAL_VISIBLE_WORLDS);

    visible.forEach((w, idx) => {
      const el = document.createElement("div");
      el.className = "world";
      el.innerHTML = `
        <header>
          <div>
            <strong>${escapeHtml(w.name)}</strong><br/>
            <small>${escapeHtml(w.host)} : ${w.port}</small>
          </div>
          <button class="btn secondary" data-select="${idx}">Select</button>
        </header>
        <div class="meta">
          <span class="chip">${w.members ? "Members" : "Free"}</span>
          ${w.activity ? `<span class="chip">${escapeHtml(w.activity)}</span>` : ""}
        </div>
        <div class="select">
          <input type="checkbox" data-check="${idx}" />
          <small class="muted">Include in measurement</small>
        </div>
      `;
      container.appendChild(el);
    });

    document.getElementById("toggleMore").textContent = showingAll ? "Show fewer" : `Show all (${allWorlds.length})`;

    // Bind selects
    container.querySelectorAll("[data-select]").forEach(btn=>{
      btn.addEventListener("click", (e)=>{
        const i = Number(btn.getAttribute("data-select"));
        const box = container.querySelector(`[data-check="${i}"]`);
        if(box){ box.checked = !box.checked; enforceMaxSelection(container); }
      });
    });
    container.querySelectorAll('input[type="checkbox"][data-check]').forEach(chk=>{
      chk.addEventListener("change", ()=> enforceMaxSelection(container));
    });
  }

  function enforceMaxSelection(container){
    const all = Array.from(container.querySelectorAll('input[type="checkbox"][data-check]'));
    const selected = all.filter(x=>x.checked);
    if(selected.length > MAX_WORLDS){
      // uncheck the newest tick
      const last = selected.pop();
      last.checked = false;
      alert(`You can select up to ${MAX_WORLDS} worlds.`);
    }
  }

  // -------- Measurement + polling --------
  function worldKey(w){ return `${w.host}:${w.port}`; }

  function resetResultsTable(worlds){
    const body = document.getElementById("resultsBody");
    body.innerHTML = "";
    worlds.forEach(w=>{
      const tr = document.createElement("tr");
      tr.id = `row-${worldKey(w)}`;
      tr.innerHTML = `
        <td>${escapeHtml(w.host)}</td>
        <td>${w.port}</td>
        <td>${w.members ? "Members" : "Free"}</td>
        <td>${w.activity ? escapeHtml(w.activity) : ""}</td>
        <td id="med-${worldKey(w)}">—</td>
        <td id="p95-${worldKey(w)}">—</td>
        <td id="jit-${worldKey(w)}">—</td>
        <td id="los-${worldKey(w)}">—</td>
        <td id="hop-${worldKey(w)}">—</td>
        <td id="fhr-${worldKey(w)}">—</td>
        <td class="status" id="st-${worldKey(w)}">queued…</td>
      `;
      body.appendChild(tr);
    });
  }

  async function startMeasurement(){
    const asn = document.getElementById("asn").value;
    const capital = document.getElementById("capital").value;
    const port = Number(document.getElementById("tcpPort").value);
    const bypass = document.getElementById("bypassCache").checked;

    // Gather selected
    const container = document.getElementById("worlds");
    const checks = Array.from(container.querySelectorAll('input[type="checkbox"][data-check]'));
    const chosenIdx = checks.filter(x=>x.checked).map(x=>Number(x.getAttribute("data-check")));

    // Map from current visible slice indexes to allWorlds indexes
    const visibleMap = showingAll ? allWorlds.map((_,i)=>i) : allWorlds.slice(0, INITIAL_VISIBLE_WORLDS).map((_,i)=>i);
    const selectedWorlds = chosenIdx.map(i => allWorlds[visibleMap[i]]);

    if(selectedWorlds.length === 0){ alert("Pick at least one world."); return; }
    if(selectedWorlds.length > MAX_WORLDS){ alert(`Max ${MAX_WORLDS} worlds.`); return; }

    resetResultsTable(selectedWorlds);

    try{
      const body = {
        asn: Number(asn),
        capital,
        worlds: selectedWorlds.map(w=>w.host),
        tcp_port: port
      };
      const url = `${API_BASE}/measure${bypass ? "?nocache=1" : ""}`;
      const r = await fetch(url, {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      if(!r.ok){
        const txt = await r.text().catch(()=> "");
        throw new Error(`Measure failed: HTTP ${r.status} ${txt}`);
      }
      const data = await r.json();
      // Poll for results
      await pollResults(data.run_id, selectedWorlds);
    }catch(err){
      console.error(err);
      alert(`Failed to start measurement.\n\n${err.message || err}`);
    }
  }

  async function pollResults(runId, worlds){
    const statusByKey = Object.fromEntries(worlds.map(w=>[worldKey(w),"waiting…"]));
    const bodyEl = document.getElementById("resultsBody");

    const sleep = ms => new Promise(r=>setTimeout(r,ms));
    const attempts = 15;
    let delay = 2000;

    for(let i=0;i<attempts;i++){
      try{
        const r = await fetch(`${API_BASE}/results?run=${encodeURIComponent(runId)}`, { cache:"no-cache" });
        if(r.ok){
          const data = await r.json();
          const rows = data?.results || [];
          for(const row of rows){
            const key = `${row.world}:${data.port ?? row.port ?? ""}`;
            const ping = row.ping || {};
            const tr = row.traceroute || {};
            setCell(`med-${key}`, fmtNum(ping.rtt_med));
            setCell(`p95-${key}`, fmtNum(ping.rtt_p95));
            setCell(`jit-${key}`, fmtNum(ping.jitter));
            setCell(`los-${key}`, fmtPct(ping.loss_pct));
            setCell(`hop-${key}`, tr.hops ?? "—");
            setCell(`fhr-${key}`, fmtNum(tr.final_hop_rtt));
            setCell(`st-${key}`, ping.samples>0 || tr.hops!=null ? "done" : "waiting…");
          }

          // All done?
          const done = rows.every(r =>
            (r.ping && r.ping.samples>0) ||
            (r.traceroute && r.traceroute.hops!=null)
          );
          if(done) return;
        } else {
          console.warn("results:", r.status);
        }
      }catch(e){ console.warn("poll error", e); }

      await sleep(delay);
      delay = Math.min(Math.round(delay*1.4), 8000);
    }

    // timeout marker
    worlds.forEach(w=>{
      const key = worldKey(w);
      const st = document.getElementById(`st-${key}`);
      if(st && /waiting/.test(st.textContent)) st.textContent = "timeout";
    });
  }

  function setCell(id, val){
    const el = document.getElementById(id);
    if(el) el.textContent = (val==null ? "—" : val);
  }
  function fmtNum(n){ return (typeof n==="number" ? n.toFixed(3) : "—"); }
  function fmtPct(n){ return (typeof n==="number" ? n.toFixed(2) : "—"); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[c])); }

  // -------- UI events --------
  document.getElementById("toggleMore").addEventListener("click", ()=>{
    showingAll = !showingAll;
    renderWorlds();
  });
  document.getElementById("startBtn").addEventListener("click", startMeasurement);

  // -------- Init --------
  (async function init(){
    await Promise.all([loadASNs(), loadWorlds()]);
  })();
</script>
</body>
</html>
